'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var zeros = require('zeros');
/**
 * Calculate local mean
 */
function localMean(pixels, size) {
  // pixels is expected to be grayscaled
  var _pixels$shape = _slicedToArray(pixels.shape, 2),
      width = _pixels$shape[0],
      height = _pixels$shape[1];
  // I like Shakutori method!


  var rowSumsCol = new Array(height);
  for (var y = 0; y < height; y++) {
    var rowSums = new Array(width).fill(0);
    for (var x = 0; x < size; x++) {
      rowSums[0] += pixels.get(x, y);
    }
    for (var xEnd = size; xEnd < width; xEnd++) {
      var xStart = xEnd - size + 1;
      rowSums[xStart] = rowSums[xStart - 1] + pixels.get(xEnd, y) - pixels.get(xStart - 1, y);
    }
    rowSumsCol[y] = rowSums;
  }

  var mWidth = width - size + 1;
  var mHeight = height - size + 1;
  var mean = zeros([mWidth, mHeight]);
  for (var _x = 0; _x < mWidth; _x++) {
    // Set x, 0
    for (var _y = 0; _y < size; _y++) {
      var prev = mean.get(_x, 0);
      mean.set(_x, 0, prev + rowSumsCol[_y][_x]);
    }
  }
  for (var _x2 = 0; _x2 < mWidth; _x2++) {
    for (var _y2 = 1; _y2 < mHeight; _y2++) {
      mean.set(_x2, _y2, mean.get(_x2, _y2 - 1) - rowSumsCol[_y2 - 1][_x2] + rowSumsCol[_y2 + size - 1][_x2]);
    }
  }

  // Devide
  for (var _x3 = 0; _x3 < mWidth; _x3++) {
    for (var _y3 = 0; _y3 < mHeight; _y3++) {
      mean.set(_x3, _y3, mean.get(_x3, _y3) / (size * size));
    }
  }
  return mean;
}

module.exports = localMean;